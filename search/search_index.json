{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Booker Getting started Domain","title":"Home"},{"location":"#booker","text":"","title":"Booker"},{"location":"#getting-started","text":"","title":"Getting started"},{"location":"#domain","text":"","title":"Domain"},{"location":"domain/","text":"Domain Ubiquitous Language Bookkeeping Bookkeeping is all about creating an accurate paper trial. Accounting methods Two accounting methods, cash and accrual. The difference is when sales and purchases are recorded. Cash-based accounting records sales and purchases when cash exchanges hands. Accrual-based accounting recourds sales and purchases when they happen. All but the smallest businesses use accrual-based accounting. A business has three financial concepts that must be kept in balance; assets, capital, and liabilities. Assets = capital + liabilities. Every transaction requires at least one debit and one credit . This is double-entry bookkeeping. The chart of accounts sets out all a business' account s and the types of transaction s that go into each one. \"The books\" or \"the accounts\" are a collection of ledger s. A ledger records groups of debit s and credit s. For example, Sales ledger : customer accounts Purchase ledger : supplier accounts General ledger : ultimately, all business activities Bank ledger : bank account inflows and outflows The information recorded in bookkeeping is ultimately used to create financial statements. The statement of financial position shows a snapshot in time of the value of assets, capital, and liabilties. The statements of financial performance shows a window of time of the value of income and expenses. Bookkeeping follows the accounting cycle over a period of time. graph TB A[Transactions] --> B[Reconciliations] B --> C[Trial Balance] C --> D[Adjusted Journal Entries] D --> E[Financial Statements] E --> F[Closing Entries] F --> A To \"close\" the accounts means to zero out all the income and expense accounts. Different types of account have different \"normal\" balances. Account Normal balance Asset Debit Capital Credit Liability Credit Income Credit Expense Debit A debit normal balance means debiting that account increases the value. The chart of accounts records which types of transaction s should affect which account s. It is probably in a specific order and includes a description for each account. Account s can be added during the period but not removed. Chart of accounts columns; Number Name Type (Asset, Capital, Liability, Income, Expense) Description of the types of transaction s to be recorded in that account Historically, splitting the act of entering debits and credits onto separate ledgers kept things simpler. Debits and credits relating to sales were all recorded in one place then the total sales for the period was entered in the general ledger. Control account reconciliations help to check the various ledgers are in agreement. For example, the debtors control account totals all the sales and customer receipts for a period. This may be compared to the aged debtors report. Not all debits and credits are the result of explicit transactions such as a sale. For example, assets depreciate in value and prepaid expenses such as insurance are used up with time. Periodic tasks Certain tasks need completing on a daily, weekly, or monthly basis. Besides the annual financial statement preparation. Businesses use checklists to keep track of which tasks have been completed for the period. Preparing financial statements Tax Reporting For decision-making... For external parties... Budgeting Bounded Contexts The same words may have different meanings inside each context or system. Ledger system Records accounts and their debits and credits. Actions include Creating accounts provided the account number / code is unique Deleting accounts provided the account has a zero balance Posting debits and credits to ledger(s) provided the transaction has a zero balance Really, two contexts... The chart of accounts system and the ledger system. For the chart of accounts Account code name description balance to permit deleting the account (last closed) For the ledger Entry ref account code date value Tip For the purposes of the ledger system, the account number is taken as read. Some other system manages account management. Ensures individual transactions balance and debit/crediting an account is idempotent. Reporting system Records groups of accounts. Returns aggregate information - not concerned with debits and credits. Includes control accounts and financial statements. Budgeting / Forecasting system ... Context Map Tactical - Entities, Values, and Aggregates classDiagram Ledger \"1\" --o \"0..n\" Entry class Ledger{ +set~Entry~ entries +post(entries) entries +balance(account) int } class Entry{ +str ref +str account +date date +Int value } Debits, credit, and decimals Debit and credit amounts are represented as positve and negative values respectively, while money amounts are in pence to avoid floating point number issues.","title":"Domain"},{"location":"domain/#domain","text":"","title":"Domain"},{"location":"domain/#ubiquitous-language","text":"","title":"Ubiquitous Language"},{"location":"domain/#bookkeeping","text":"Bookkeeping is all about creating an accurate paper trial. Accounting methods Two accounting methods, cash and accrual. The difference is when sales and purchases are recorded. Cash-based accounting records sales and purchases when cash exchanges hands. Accrual-based accounting recourds sales and purchases when they happen. All but the smallest businesses use accrual-based accounting. A business has three financial concepts that must be kept in balance; assets, capital, and liabilities. Assets = capital + liabilities. Every transaction requires at least one debit and one credit . This is double-entry bookkeeping. The chart of accounts sets out all a business' account s and the types of transaction s that go into each one. \"The books\" or \"the accounts\" are a collection of ledger s. A ledger records groups of debit s and credit s. For example, Sales ledger : customer accounts Purchase ledger : supplier accounts General ledger : ultimately, all business activities Bank ledger : bank account inflows and outflows The information recorded in bookkeeping is ultimately used to create financial statements. The statement of financial position shows a snapshot in time of the value of assets, capital, and liabilties. The statements of financial performance shows a window of time of the value of income and expenses. Bookkeeping follows the accounting cycle over a period of time. graph TB A[Transactions] --> B[Reconciliations] B --> C[Trial Balance] C --> D[Adjusted Journal Entries] D --> E[Financial Statements] E --> F[Closing Entries] F --> A To \"close\" the accounts means to zero out all the income and expense accounts. Different types of account have different \"normal\" balances. Account Normal balance Asset Debit Capital Credit Liability Credit Income Credit Expense Debit A debit normal balance means debiting that account increases the value. The chart of accounts records which types of transaction s should affect which account s. It is probably in a specific order and includes a description for each account. Account s can be added during the period but not removed. Chart of accounts columns; Number Name Type (Asset, Capital, Liability, Income, Expense) Description of the types of transaction s to be recorded in that account Historically, splitting the act of entering debits and credits onto separate ledgers kept things simpler. Debits and credits relating to sales were all recorded in one place then the total sales for the period was entered in the general ledger. Control account reconciliations help to check the various ledgers are in agreement. For example, the debtors control account totals all the sales and customer receipts for a period. This may be compared to the aged debtors report. Not all debits and credits are the result of explicit transactions such as a sale. For example, assets depreciate in value and prepaid expenses such as insurance are used up with time.","title":"Bookkeeping"},{"location":"domain/#periodic-tasks","text":"Certain tasks need completing on a daily, weekly, or monthly basis. Besides the annual financial statement preparation. Businesses use checklists to keep track of which tasks have been completed for the period.","title":"Periodic tasks"},{"location":"domain/#preparing-financial-statements","text":"","title":"Preparing financial statements"},{"location":"domain/#tax","text":"","title":"Tax"},{"location":"domain/#reporting","text":"For decision-making... For external parties...","title":"Reporting"},{"location":"domain/#budgeting","text":"","title":"Budgeting"},{"location":"domain/#bounded-contexts","text":"The same words may have different meanings inside each context or system.","title":"Bounded Contexts"},{"location":"domain/#ledger-system","text":"Records accounts and their debits and credits. Actions include Creating accounts provided the account number / code is unique Deleting accounts provided the account has a zero balance Posting debits and credits to ledger(s) provided the transaction has a zero balance Really, two contexts... The chart of accounts system and the ledger system. For the chart of accounts Account code name description balance to permit deleting the account (last closed) For the ledger Entry ref account code date value Tip For the purposes of the ledger system, the account number is taken as read. Some other system manages account management. Ensures individual transactions balance and debit/crediting an account is idempotent.","title":"Ledger system"},{"location":"domain/#reporting-system","text":"Records groups of accounts. Returns aggregate information - not concerned with debits and credits. Includes control accounts and financial statements.","title":"Reporting system"},{"location":"domain/#budgeting-forecasting-system","text":"...","title":"Budgeting / Forecasting system"},{"location":"domain/#context-map","text":"","title":"Context Map"},{"location":"domain/#tactical-entities-values-and-aggregates","text":"classDiagram Ledger \"1\" --o \"0..n\" Entry class Ledger{ +set~Entry~ entries +post(entries) entries +balance(account) int } class Entry{ +str ref +str account +date date +Int value } Debits, credit, and decimals Debit and credit amounts are represented as positve and negative values respectively, while money amounts are in pence to avoid floating point number issues.","title":"Tactical - Entities, Values, and Aggregates"},{"location":"getting_started/","text":"Getting Started","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"roadmap/","text":"Roadmap ledger Transations, acounts, debits and credits ... to facilitate the accounting cycle ... but not grouping accounts, scheduling periodic tasks, dealing with inventory, ... report Grouping of accounts","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"","title":"Roadmap"},{"location":"roadmap/#ledger","text":"Transations, acounts, debits and credits ... to facilitate the accounting cycle ... but not grouping accounts, scheduling periodic tasks, dealing with inventory, ...","title":"ledger"},{"location":"roadmap/#report","text":"Grouping of accounts","title":"report"},{"location":"api/domain/","text":"ClosingError ( LedgerError ) ClosingError base Exception. Source code in ledger/domain.py class ClosingError ( LedgerError ): \"\"\"ClosingError base Exception.\"\"\" Entry dataclass Ledger entry. Parameters: Name Type Description Default ref str Reference ID for 1+ Entry objects. required account str Account code. required date date_cls Date of Entry. required value int Value of Entry in pence. required Source code in ledger/domain.py @dataclass ( unsafe_hash = True ) class Entry : \"\"\"Ledger entry. Args: ref: Reference ID for 1+ Entry objects. account: Account code. date: Date of Entry. value: Value of Entry in pence. \"\"\" ref : str account : str date : date_cls value : int @classmethod def from_dict ( cls , d : dict [ str , str | int ]) -> Entry : ref = str ( d [ \"ref\" ]) account = str ( d [ \"account\" ]) date = date_cls . fromisoformat ( str ( d [ \"date\" ])) value = int ( d [ \"value\" ]) return Entry ( ref = ref , account = account , date = date , value = value , ) def __repr__ ( self ): return f \"<Entry( { self . ref } , { self . account } , { self . date } , { self . value } )>\" def to_dict ( self ) -> dict [ str , Any ]: d = asdict ( self ) d [ \"date\" ] = d [ \"date\" ] . isoformat () return d Ledger Ledger. The version attribute is to prevent multiple processes writing to the same ledger simultaneously. Parameters: Name Type Description Default name str Name of the Ledger e.g. \"General\" required entries Optional[set[Entry]] Entry objects associated with the Ledger. None version int Helps to prevent concurrent writes. 0 Source code in ledger/domain.py class Ledger : \"\"\"Ledger. The version attribute is to prevent multiple processes writing to the same ledger simultaneously. Args: name: Name of the Ledger e.g. \"General\" entries: Entry objects associated with the Ledger. version: Helps to prevent concurrent writes. \"\"\" # Tempting to put get classmethods here but they go on the unit of work. def __init__ ( self , name : str , entries : Optional [ set [ Entry ]] = None , version : int = 0 ) -> None : self . name = name self . entries : set [ Entry ] = set () if entries is None else entries self . version = version def __repr__ ( self ): return f \"<Ledger( { self . name } )>\" def post ( self , entries : set [ Entry ]) -> set [ Entry ]: \"\"\"Post entries to the ledger. Args: entries: Entry objects to post Raises: TransactionDoesNotBalance: The entries do not balance. Returns: Entries added to the ledger. \"\"\" if sum ( e . value for e in entries ) != 0 : raise PostingError ( \"Entries do not balance\" ) # dangerous to not make a new object? e.g. set(...) original_entries = self . entries self . entries = original_entries | entries return self . entries - original_entries def balance ( self , account : str , date : date_cls ) -> int : \"\"\"Get the balance for an account code. Args: account: Account code. Raises: NoSuchAccount: No corresponding account code in the ledger. Returns: Sum of the entries for the corresponding account. \"\"\" entries = set ( e for e in self . entries if e . account == account and e . date <= date ) if not entries : raise NoSuchAccount ( f \"No entries for account ' { account } '\" f \"prior to { date . strftime ( '%Y-%m- %d ' ) } \" ) return sum ( e . value for e in entries ) def close_to ( self , ref : str , ledger : Ledger , date : date_cls ) -> set [ Entry ]: \"\"\"Zero-out all accounts with non-zero balances and post corresponding entries to the given ledger. Args: ledger: Ledger to post closing entries to. date: Latest date to include entries from (inclusive). Raises: ClosingError: Issue closing the ledger. Returns: The closing enries. \"\"\" # potentially a lot of entries but is only for a single ledger so may # not get too crazy accounts = set ( e . account for e in self . entries ) zeroing_out_entries = set ( Entry ( ref , a , date , bal * - 1 ) for a in accounts if ( bal := self . balance ( a , date )) ) posted_zeroing_out_entries = self . post ( zeroing_out_entries ) if len ( posted_zeroing_out_entries ) != len ( zeroing_out_entries ): raise ClosingError ( f \"Is the reference, { ref } , correct?\" ) closing_entries = set ( Entry ( ref , e . account , date , e . value * - 1 ) for e in zeroing_out_entries ) # if there is an exception here, # need to reverse out the posted_zeroing_out_entries # haven't found a way to test it though posted_closing_entries = ledger . post ( closing_entries ) if len ( posted_closing_entries ) != len ( closing_entries ): self . entries = self . entries - posted_zeroing_out_entries raise ClosingError ( f \"Is the reference, { ref } , correct?\" ) return posted_closing_entries balance ( self , account , date ) Get the balance for an account code. Parameters: Name Type Description Default account str Account code. required Exceptions: Type Description NoSuchAccount No corresponding account code in the ledger. Returns: Type Description int Sum of the entries for the corresponding account. Source code in ledger/domain.py def balance ( self , account : str , date : date_cls ) -> int : \"\"\"Get the balance for an account code. Args: account: Account code. Raises: NoSuchAccount: No corresponding account code in the ledger. Returns: Sum of the entries for the corresponding account. \"\"\" entries = set ( e for e in self . entries if e . account == account and e . date <= date ) if not entries : raise NoSuchAccount ( f \"No entries for account ' { account } '\" f \"prior to { date . strftime ( '%Y-%m- %d ' ) } \" ) return sum ( e . value for e in entries ) close_to ( self , ref , ledger , date ) Zero-out all accounts with non-zero balances and post corresponding entries to the given ledger. Parameters: Name Type Description Default ledger Ledger Ledger to post closing entries to. required date date_cls Latest date to include entries from (inclusive). required Exceptions: Type Description ClosingError Issue closing the ledger. Returns: Type Description set[Entry] The closing enries. Source code in ledger/domain.py def close_to ( self , ref : str , ledger : Ledger , date : date_cls ) -> set [ Entry ]: \"\"\"Zero-out all accounts with non-zero balances and post corresponding entries to the given ledger. Args: ledger: Ledger to post closing entries to. date: Latest date to include entries from (inclusive). Raises: ClosingError: Issue closing the ledger. Returns: The closing enries. \"\"\" # potentially a lot of entries but is only for a single ledger so may # not get too crazy accounts = set ( e . account for e in self . entries ) zeroing_out_entries = set ( Entry ( ref , a , date , bal * - 1 ) for a in accounts if ( bal := self . balance ( a , date )) ) posted_zeroing_out_entries = self . post ( zeroing_out_entries ) if len ( posted_zeroing_out_entries ) != len ( zeroing_out_entries ): raise ClosingError ( f \"Is the reference, { ref } , correct?\" ) closing_entries = set ( Entry ( ref , e . account , date , e . value * - 1 ) for e in zeroing_out_entries ) # if there is an exception here, # need to reverse out the posted_zeroing_out_entries # haven't found a way to test it though posted_closing_entries = ledger . post ( closing_entries ) if len ( posted_closing_entries ) != len ( closing_entries ): self . entries = self . entries - posted_zeroing_out_entries raise ClosingError ( f \"Is the reference, { ref } , correct?\" ) return posted_closing_entries post ( self , entries ) Post entries to the ledger. Parameters: Name Type Description Default entries set[Entry] Entry objects to post required Exceptions: Type Description TransactionDoesNotBalance The entries do not balance. Returns: Type Description set[Entry] Entries added to the ledger. Source code in ledger/domain.py def post ( self , entries : set [ Entry ]) -> set [ Entry ]: \"\"\"Post entries to the ledger. Args: entries: Entry objects to post Raises: TransactionDoesNotBalance: The entries do not balance. Returns: Entries added to the ledger. \"\"\" if sum ( e . value for e in entries ) != 0 : raise PostingError ( \"Entries do not balance\" ) # dangerous to not make a new object? e.g. set(...) original_entries = self . entries self . entries = original_entries | entries return self . entries - original_entries LedgerError ( Exception ) Ledger domain base Exception. Source code in ledger/domain.py class LedgerError ( Exception ): \"\"\"Ledger domain base Exception.\"\"\" NoSuchAccount ( LedgerError ) No such account code in the ledger. As opposed to, say, an account with zero balance. Source code in ledger/domain.py class NoSuchAccount ( LedgerError ): \"\"\"No such account code in the ledger. As opposed to, say, an account with zero balance. \"\"\" PostingError ( LedgerError ) PostingError base Exception. Source code in ledger/domain.py class PostingError ( LedgerError ): \"\"\"PostingError base Exception.\"\"\" TransactionDoesNotBalance ( PostingError ) The entries do not balance. Source code in ledger/domain.py class TransactionDoesNotBalance ( PostingError ): \"\"\"The entries do not balance.\"\"\"","title":"Domain"},{"location":"api/domain/#ledger.domain.ClosingError","text":"ClosingError base Exception. Source code in ledger/domain.py class ClosingError ( LedgerError ): \"\"\"ClosingError base Exception.\"\"\"","title":"ClosingError"},{"location":"api/domain/#ledger.domain.Entry","text":"Ledger entry. Parameters: Name Type Description Default ref str Reference ID for 1+ Entry objects. required account str Account code. required date date_cls Date of Entry. required value int Value of Entry in pence. required Source code in ledger/domain.py @dataclass ( unsafe_hash = True ) class Entry : \"\"\"Ledger entry. Args: ref: Reference ID for 1+ Entry objects. account: Account code. date: Date of Entry. value: Value of Entry in pence. \"\"\" ref : str account : str date : date_cls value : int @classmethod def from_dict ( cls , d : dict [ str , str | int ]) -> Entry : ref = str ( d [ \"ref\" ]) account = str ( d [ \"account\" ]) date = date_cls . fromisoformat ( str ( d [ \"date\" ])) value = int ( d [ \"value\" ]) return Entry ( ref = ref , account = account , date = date , value = value , ) def __repr__ ( self ): return f \"<Entry( { self . ref } , { self . account } , { self . date } , { self . value } )>\" def to_dict ( self ) -> dict [ str , Any ]: d = asdict ( self ) d [ \"date\" ] = d [ \"date\" ] . isoformat () return d","title":"Entry"},{"location":"api/domain/#ledger.domain.Ledger","text":"Ledger. The version attribute is to prevent multiple processes writing to the same ledger simultaneously. Parameters: Name Type Description Default name str Name of the Ledger e.g. \"General\" required entries Optional[set[Entry]] Entry objects associated with the Ledger. None version int Helps to prevent concurrent writes. 0 Source code in ledger/domain.py class Ledger : \"\"\"Ledger. The version attribute is to prevent multiple processes writing to the same ledger simultaneously. Args: name: Name of the Ledger e.g. \"General\" entries: Entry objects associated with the Ledger. version: Helps to prevent concurrent writes. \"\"\" # Tempting to put get classmethods here but they go on the unit of work. def __init__ ( self , name : str , entries : Optional [ set [ Entry ]] = None , version : int = 0 ) -> None : self . name = name self . entries : set [ Entry ] = set () if entries is None else entries self . version = version def __repr__ ( self ): return f \"<Ledger( { self . name } )>\" def post ( self , entries : set [ Entry ]) -> set [ Entry ]: \"\"\"Post entries to the ledger. Args: entries: Entry objects to post Raises: TransactionDoesNotBalance: The entries do not balance. Returns: Entries added to the ledger. \"\"\" if sum ( e . value for e in entries ) != 0 : raise PostingError ( \"Entries do not balance\" ) # dangerous to not make a new object? e.g. set(...) original_entries = self . entries self . entries = original_entries | entries return self . entries - original_entries def balance ( self , account : str , date : date_cls ) -> int : \"\"\"Get the balance for an account code. Args: account: Account code. Raises: NoSuchAccount: No corresponding account code in the ledger. Returns: Sum of the entries for the corresponding account. \"\"\" entries = set ( e for e in self . entries if e . account == account and e . date <= date ) if not entries : raise NoSuchAccount ( f \"No entries for account ' { account } '\" f \"prior to { date . strftime ( '%Y-%m- %d ' ) } \" ) return sum ( e . value for e in entries ) def close_to ( self , ref : str , ledger : Ledger , date : date_cls ) -> set [ Entry ]: \"\"\"Zero-out all accounts with non-zero balances and post corresponding entries to the given ledger. Args: ledger: Ledger to post closing entries to. date: Latest date to include entries from (inclusive). Raises: ClosingError: Issue closing the ledger. Returns: The closing enries. \"\"\" # potentially a lot of entries but is only for a single ledger so may # not get too crazy accounts = set ( e . account for e in self . entries ) zeroing_out_entries = set ( Entry ( ref , a , date , bal * - 1 ) for a in accounts if ( bal := self . balance ( a , date )) ) posted_zeroing_out_entries = self . post ( zeroing_out_entries ) if len ( posted_zeroing_out_entries ) != len ( zeroing_out_entries ): raise ClosingError ( f \"Is the reference, { ref } , correct?\" ) closing_entries = set ( Entry ( ref , e . account , date , e . value * - 1 ) for e in zeroing_out_entries ) # if there is an exception here, # need to reverse out the posted_zeroing_out_entries # haven't found a way to test it though posted_closing_entries = ledger . post ( closing_entries ) if len ( posted_closing_entries ) != len ( closing_entries ): self . entries = self . entries - posted_zeroing_out_entries raise ClosingError ( f \"Is the reference, { ref } , correct?\" ) return posted_closing_entries","title":"Ledger"},{"location":"api/domain/#ledger.domain.Ledger.balance","text":"Get the balance for an account code. Parameters: Name Type Description Default account str Account code. required Exceptions: Type Description NoSuchAccount No corresponding account code in the ledger. Returns: Type Description int Sum of the entries for the corresponding account. Source code in ledger/domain.py def balance ( self , account : str , date : date_cls ) -> int : \"\"\"Get the balance for an account code. Args: account: Account code. Raises: NoSuchAccount: No corresponding account code in the ledger. Returns: Sum of the entries for the corresponding account. \"\"\" entries = set ( e for e in self . entries if e . account == account and e . date <= date ) if not entries : raise NoSuchAccount ( f \"No entries for account ' { account } '\" f \"prior to { date . strftime ( '%Y-%m- %d ' ) } \" ) return sum ( e . value for e in entries )","title":"balance()"},{"location":"api/domain/#ledger.domain.Ledger.close_to","text":"Zero-out all accounts with non-zero balances and post corresponding entries to the given ledger. Parameters: Name Type Description Default ledger Ledger Ledger to post closing entries to. required date date_cls Latest date to include entries from (inclusive). required Exceptions: Type Description ClosingError Issue closing the ledger. Returns: Type Description set[Entry] The closing enries. Source code in ledger/domain.py def close_to ( self , ref : str , ledger : Ledger , date : date_cls ) -> set [ Entry ]: \"\"\"Zero-out all accounts with non-zero balances and post corresponding entries to the given ledger. Args: ledger: Ledger to post closing entries to. date: Latest date to include entries from (inclusive). Raises: ClosingError: Issue closing the ledger. Returns: The closing enries. \"\"\" # potentially a lot of entries but is only for a single ledger so may # not get too crazy accounts = set ( e . account for e in self . entries ) zeroing_out_entries = set ( Entry ( ref , a , date , bal * - 1 ) for a in accounts if ( bal := self . balance ( a , date )) ) posted_zeroing_out_entries = self . post ( zeroing_out_entries ) if len ( posted_zeroing_out_entries ) != len ( zeroing_out_entries ): raise ClosingError ( f \"Is the reference, { ref } , correct?\" ) closing_entries = set ( Entry ( ref , e . account , date , e . value * - 1 ) for e in zeroing_out_entries ) # if there is an exception here, # need to reverse out the posted_zeroing_out_entries # haven't found a way to test it though posted_closing_entries = ledger . post ( closing_entries ) if len ( posted_closing_entries ) != len ( closing_entries ): self . entries = self . entries - posted_zeroing_out_entries raise ClosingError ( f \"Is the reference, { ref } , correct?\" ) return posted_closing_entries","title":"close_to()"},{"location":"api/domain/#ledger.domain.Ledger.post","text":"Post entries to the ledger. Parameters: Name Type Description Default entries set[Entry] Entry objects to post required Exceptions: Type Description TransactionDoesNotBalance The entries do not balance. Returns: Type Description set[Entry] Entries added to the ledger. Source code in ledger/domain.py def post ( self , entries : set [ Entry ]) -> set [ Entry ]: \"\"\"Post entries to the ledger. Args: entries: Entry objects to post Raises: TransactionDoesNotBalance: The entries do not balance. Returns: Entries added to the ledger. \"\"\" if sum ( e . value for e in entries ) != 0 : raise PostingError ( \"Entries do not balance\" ) # dangerous to not make a new object? e.g. set(...) original_entries = self . entries self . entries = original_entries | entries return self . entries - original_entries","title":"post()"},{"location":"api/domain/#ledger.domain.LedgerError","text":"Ledger domain base Exception. Source code in ledger/domain.py class LedgerError ( Exception ): \"\"\"Ledger domain base Exception.\"\"\"","title":"LedgerError"},{"location":"api/domain/#ledger.domain.NoSuchAccount","text":"No such account code in the ledger. As opposed to, say, an account with zero balance. Source code in ledger/domain.py class NoSuchAccount ( LedgerError ): \"\"\"No such account code in the ledger. As opposed to, say, an account with zero balance. \"\"\"","title":"NoSuchAccount"},{"location":"api/domain/#ledger.domain.PostingError","text":"PostingError base Exception. Source code in ledger/domain.py class PostingError ( LedgerError ): \"\"\"PostingError base Exception.\"\"\"","title":"PostingError"},{"location":"api/domain/#ledger.domain.TransactionDoesNotBalance","text":"The entries do not balance. Source code in ledger/domain.py class TransactionDoesNotBalance ( PostingError ): \"\"\"The entries do not balance.\"\"\"","title":"TransactionDoesNotBalance"},{"location":"api/repository/","text":"Repository ( Protocol ) Repository protocol Source code in ledger/repository.py class Repository ( Protocol ): \"\"\"Repository protocol\"\"\" session : Session def add ( self , ledger : Ledger ) -> None : ... def get ( self , name : str ) -> Ledger : ... def list ( self ) -> Iterable [ Ledger ]: ... SQLAlchemyRepository SQLAlchemyRepository Source code in ledger/repository.py class SQLAlchemyRepository : \"\"\"SQLAlchemyRepository\"\"\" def __init__ ( self , session : Session ): self . session = session def add ( self , ledger : Ledger ) -> None : self . session . add ( ledger ) def get ( self , name : str ) -> Ledger : return self . session . query ( Ledger ) . filter_by ( name = name ) . one () def list ( self ) -> Iterable [ Ledger ]: return self . session . query ( Ledger ) . all ()","title":"Repository"},{"location":"api/repository/#ledger.repository.Repository","text":"Repository protocol Source code in ledger/repository.py class Repository ( Protocol ): \"\"\"Repository protocol\"\"\" session : Session def add ( self , ledger : Ledger ) -> None : ... def get ( self , name : str ) -> Ledger : ... def list ( self ) -> Iterable [ Ledger ]: ...","title":"Repository"},{"location":"api/repository/#ledger.repository.SQLAlchemyRepository","text":"SQLAlchemyRepository Source code in ledger/repository.py class SQLAlchemyRepository : \"\"\"SQLAlchemyRepository\"\"\" def __init__ ( self , session : Session ): self . session = session def add ( self , ledger : Ledger ) -> None : self . session . add ( ledger ) def get ( self , name : str ) -> Ledger : return self . session . query ( Ledger ) . filter_by ( name = name ) . one () def list ( self ) -> Iterable [ Ledger ]: return self . session . query ( Ledger ) . all ()","title":"SQLAlchemyRepository"},{"location":"api/services/","text":"DuplicateLedger ( LedgerError ) Ledger names must be unique. Source code in ledger/services.py class DuplicateLedger ( domain . LedgerError ): \"\"\"Ledger names must be unique.\"\"\" add_ledger ( name , uow ) Create a Ledger. Parameters: Name Type Description Default name str Name of the Ledger. Must be unique. required uow UnitOfWork UnitOfWork object. required Returns: Type Description dict {\"name\": <name of the Ledger>} Source code in ledger/services.py def add_ledger ( name : str , uow : unit_of_work . UnitOfWork ) -> dict [ str , str ]: \"\"\"Create a Ledger. Args: name: Name of the Ledger. Must be unique. uow: UnitOfWork object. Raises: DuplicateLedger Returns: dict: `{\"name\": <name of the Ledger>}` \"\"\" with uow : ledger = domain . Ledger ( name = name ) uow . ledgers . add ( ledger ) try : uow . commit () except IntegrityError : raise DuplicateLedger ( f \"Ledger ' { name } ' already exists.\" ) return { \"name\" : name }","title":"Services"},{"location":"api/services/#ledger.services.DuplicateLedger","text":"Ledger names must be unique. Source code in ledger/services.py class DuplicateLedger ( domain . LedgerError ): \"\"\"Ledger names must be unique.\"\"\"","title":"DuplicateLedger"},{"location":"api/services/#ledger.services.add_ledger","text":"Create a Ledger. Parameters: Name Type Description Default name str Name of the Ledger. Must be unique. required uow UnitOfWork UnitOfWork object. required Returns: Type Description dict {\"name\": <name of the Ledger>} Source code in ledger/services.py def add_ledger ( name : str , uow : unit_of_work . UnitOfWork ) -> dict [ str , str ]: \"\"\"Create a Ledger. Args: name: Name of the Ledger. Must be unique. uow: UnitOfWork object. Raises: DuplicateLedger Returns: dict: `{\"name\": <name of the Ledger>}` \"\"\" with uow : ledger = domain . Ledger ( name = name ) uow . ledgers . add ( ledger ) try : uow . commit () except IntegrityError : raise DuplicateLedger ( f \"Ledger ' { name } ' already exists.\" ) return { \"name\" : name }","title":"add_ledger()"},{"location":"api/uow/","text":"SqlAlchemyUnitOfWork SQLAlchemy Unit of Work. Source code in ledger/uow.py class SqlAlchemyUnitOfWork : \"\"\"SQLAlchemy Unit of Work.\"\"\" def __init__ ( self , session_factory = DEFAULT_SESSION_FACTORY ): self . session_factory = session_factory def __enter__ ( self ): self . session : Session = self . session_factory () self . ledgers : repository . Repository = repository . SQLAlchemyRepository ( self . session ) return self def __exit__ ( self , * args ): self . rollback () self . session . close () def commit ( self ): self . session . commit () def rollback ( self ): self . session . rollback () UnitOfWork ( Protocol ) Unit of Work protocol. Source code in ledger/uow.py class UnitOfWork ( Protocol ): \"\"\"Unit of Work protocol.\"\"\" ledgers : repository . Repository def __enter__ ( self ) -> UnitOfWork : ... def __exit__ ( self , * args ): ... def commit ( self ): ... def rollback ( self ): ...","title":"Unit of Work"},{"location":"api/uow/#ledger.uow.SqlAlchemyUnitOfWork","text":"SQLAlchemy Unit of Work. Source code in ledger/uow.py class SqlAlchemyUnitOfWork : \"\"\"SQLAlchemy Unit of Work.\"\"\" def __init__ ( self , session_factory = DEFAULT_SESSION_FACTORY ): self . session_factory = session_factory def __enter__ ( self ): self . session : Session = self . session_factory () self . ledgers : repository . Repository = repository . SQLAlchemyRepository ( self . session ) return self def __exit__ ( self , * args ): self . rollback () self . session . close () def commit ( self ): self . session . commit () def rollback ( self ): self . session . rollback ()","title":"SqlAlchemyUnitOfWork"},{"location":"api/uow/#ledger.uow.UnitOfWork","text":"Unit of Work protocol. Source code in ledger/uow.py class UnitOfWork ( Protocol ): \"\"\"Unit of Work protocol.\"\"\" ledgers : repository . Repository def __enter__ ( self ) -> UnitOfWork : ... def __exit__ ( self , * args ): ... def commit ( self ): ... def rollback ( self ): ...","title":"UnitOfWork"}]}